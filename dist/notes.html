<!DOCTYPE html>
<html>
  <head>
    <title>[Contains Duplicate](https://leetcode.com/problems/contains-duplicate/)</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link type="text/css" rel="stylesheet" href="assets/style.css" />
    <link type="text/css" rel="stylesheet" href="assets/pilcrow.css" />
    <link type="text/css" rel="stylesheet" href="assets/hljs-github.min.css"/>
  </head>
<body><h1 align="center">2 Weeks Study Plan to Tackle DS ðŸ’» (LeetCode)</h1>
<h2 align="center">Day 1</h2>

<h2 id="contains-duplicate"><a class="header-link" href="#contains-duplicate"></a><a href="https://leetcode.com/problems/contains-duplicate/">Contains Duplicate</a></h2>
<blockquote>
<p>Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.</p>
</blockquote>
<pre class="hljs"><code><span class="hljs-comment">// Brute force: Iterate through and find if numbers are equal then return true;</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsDuplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>{
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) {
           <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>; j &lt; nums.length; j++) {
            <span class="hljs-keyword">if</span>(nums[i] == nums[j]) {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
            }
           } 
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    }
}</code></pre><p>Or,</p>
<pre class="hljs"><code><span class="hljs-comment">// Using Set DataStructure, Set doesnâ€™t allow duplicates to insert, if duplicates are inserted it return false;</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsDuplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>{
        Set&lt;Number&gt; store = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(); 
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) { 
            <span class="hljs-keyword">if</span> (store.add(num) == <span class="hljs-keyword">false</span>) { 
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    }
}</code></pre><h2 id="maximum-subarray"><a class="header-link" href="#maximum-subarray"></a><a href="https://leetcode.com/problems/maximum-subarray/">Maximum Subarray</a></h2>
<blockquote>
<p>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p>
</blockquote>
<pre class="hljs"><code><span class="hljs-comment">// Brute force way would be to find all possible combination and return the maximum sum</span>
<span class="hljs-comment">// 4, 3, -2, 6, -14, 7, -1, 4, 5, 7, -10, 2, 9, -10, -5, -9, 6, 1</span>

<span class="hljs-comment">// Consider the 0th index value as the maximum currentSum &amp; OverAll Sum. Starte a simple for loop from the 1st index because the 0th is already taken. So, inside the loop, overall idea ye hai ki jo v new element aa rhi hai wo sochta hai ki agar mai individual continue krunga to fayde me rhunga ya currentSum se jurne me fayde me rhungaâ€¦ Agar individual me fayda hota hai to currentSum wo khud ko declare kr deta hai ya wo currentSum ke add ho jata h. Aur har iteration me maxSum ko currentSum ke sath compare krke dekh leta h aur update kr deta h. </span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>{
        <span class="hljs-keyword">int</span> currentSum = nums[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">int</span> overAllSum = nums[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) {
            <span class="hljs-comment">// agar pichhe se positive aa rha to sath ho jaane me fayda h</span>
            <span class="hljs-keyword">if</span>(currentSum &gt;= <span class="hljs-number">0</span>) {
                currentSum += nums[i];
            } <span class="hljs-keyword">else</span> {
                currentSum = nums[i];
            }
            <span class="hljs-keyword">if</span>(currentSum &gt; overAllSum) {
                overAllSum = currentSum;
            }
        }
        <span class="hljs-keyword">return</span> overAllSum;
    }
}</code></pre><p>Or,</p>
<pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>{
        <span class="hljs-keyword">int</span> maxSum = nums[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">int</span> currentSum = maxSum;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++){
            currentSum = Math.max(nums[i] + currentSum, nums[i]);
            maxSum = Math.max(currentSum, maxSum);
        }
        <span class="hljs-keyword">return</span> maxSum;
    }
}</code></pre><hr>

<h2 align="center">Day 2</h2>

<h2 id="two-sum"><a class="header-link" href="#two-sum"></a><a href="https://leetcode.com/problems/two-sum/">Two Sum</a></h2>
<blockquote>
<p>Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
You can return the answer in any order.</p>
</blockquote>
<pre class="hljs"><code><span class="hljs-comment">// Brute Force</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) {
    <span class="hljs-comment">// This loop will consider first</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++){
        <span class="hljs-comment">// This loop helps to provide one value ahead from previous value</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.length; j++){
            <span class="hljs-comment">// We are comparing the jth value with target - ith value.</span>
            <span class="hljs-comment">// If they are same we will return our indices in the array.</span>
            <span class="hljs-keyword">if</span>(nums[j] == target - nums[i]){
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] {i, j};
            }
        }
    }
    <span class="hljs-comment">// If unable to get return empty array</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{};
}</code></pre><p>Or,</p>
<pre class="hljs"><code><span class="hljs-comment">// Optimal Solution(HashMap)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) {
    <span class="hljs-comment">// inserted Value &amp; Indices</span>
    HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
    
    <span class="hljs-comment">// Filling the HashMap</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++){
        map.put(nums[i], i);
    }
    <span class="hljs-comment">// Searching for the target indices</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++){
        <span class="hljs-comment">// I will get my first element Example:- [2,7,11,15], target = 9</span>
        <span class="hljs-keyword">int</span> num = nums[i]; <span class="hljs-comment">// I will get 2 </span>
        <span class="hljs-keyword">int</span> rem = target - num; <span class="hljs-comment">// Calculating remaining value = 9 - 2 = 7 will get from here</span>
        <span class="hljs-keyword">if</span>(map.containsKey(rem)){ <span class="hljs-comment">// Now I will check that on any index 7 is present.</span>
            <span class="hljs-keyword">int</span> index = map.get(rem); <span class="hljs-comment">// From here i will get the index for no. 7</span>
            <span class="hljs-keyword">if</span>(index == i) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// By doing this i will handle the case to not select more then one of yourself.</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{i, index}; <span class="hljs-comment">// returning the array with their indices.</span>
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{}; <span class="hljs-comment">// If we are unable to find return empty array.</span>
}</code></pre><h2 id="merge-sorted-array"><a class="header-link" href="#merge-sorted-array"></a><a href="https://leetcode.com/problems/merge-sorted-array/">Merge Sorted Array</a></h2>
<blockquote>
<p>You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.
Merge nums1 and nums2 into a single array sorted in non-decreasing order.
The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.</p>
</blockquote>
<pre class="hljs"><code><span class="hljs-comment">// Straight Forward Approach</span>
<span class="hljs-comment">/*
    
    They have given the value of m and n in the question itself. 
    So, we have to start inserting the values from the num2 array after the value of m.
    
    (i.e If the value of m is 3, you should start inserting elements from num2 in the 4th index of num1.)
    
    */</span>
    
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span>[] nums2, <span class="hljs-keyword">int</span> n)</span> </span>{
        <span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=m; i&lt;nums1.length; i++) <span class="hljs-comment">// traversing num1 such that to fill the remaining values from num2</span>
        {

            nums1[i] = nums2[count];<span class="hljs-comment">// inserting in nums1</span>
            count++; <span class="hljs-comment">// increasing the count to retrieve next value from num2</span>
        }
        Arrays.sort(nums1); <span class="hljs-comment">// sort the array finally to print in ascending order!</span>
    }
}</code></pre><p>Or,</p>
<pre class="hljs"><code><span class="hljs-comment">// Two Pointer Method</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span>[] nums2, <span class="hljs-keyword">int</span> n)</span> </span>{
     <span class="hljs-comment">// Comparing Last valid element of both arrays and inserting the bigger one at the last position of the 1st array.</span>
        <span class="hljs-keyword">int</span> i = m - <span class="hljs-number">1</span>; <span class="hljs-comment">// start pointer</span>
        <span class="hljs-keyword">int</span> j = n - <span class="hljs-number">1</span>; <span class="hljs-comment">// end pointer</span>
        <span class="hljs-keyword">int</span> index = nums1.length - <span class="hljs-number">1</span>; <span class="hljs-comment">// mid</span>
        <span class="hljs-keyword">while</span> (index &gt;= <span class="hljs-number">0</span> &amp;&amp; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">if</span>(nums1[i] &gt; nums2[j])  {
                nums1[index] = nums1[i];
                i--;
                index--;
            } <span class="hljs-keyword">else</span> {
                nums1[index] = nums2[j];
                j--;
                index--;
            }
        }
        <span class="hljs-comment">// Check for check in case some elements from nums2 are still there. </span>
        <span class="hljs-comment">// No need to do the same for nums1, it would be already sorted and in place</span>
        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span>) {
            nums1[index--] = nums2[j--];
        }
    }
}</code></pre><hr>

<h2 align="center">Day 3</h2>

<h2 id="intersection-of-two-arrays-ii"><a class="header-link" href="#intersection-of-two-arrays-ii"></a><a href="https://leetcode.com/problems/intersection-of-two-arrays-ii/">Intersection of Two Arrays II</a></h2>
<blockquote>
<p>Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.</p>
</blockquote>
<pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] intersect(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2) {
        List&lt;Integer&gt; arr = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();
        HashMap&lt;Integer, Integer&gt; hm1 = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
        HashMap&lt;Integer, Integer&gt; hm2 = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
        
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums1.length; i++) {
            <span class="hljs-keyword">if</span>(hm1.containsKey(nums1[i])) {
                hm1.put(nums1[i], hm1.get(nums1[i])+<span class="hljs-number">1</span>);
            } <span class="hljs-keyword">else</span> {
                hm1.put(nums1[i], <span class="hljs-number">1</span>);
            }
        }
        
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums2.length; i++) {
            <span class="hljs-keyword">if</span>(hm2.containsKey(nums2[i])) {
                hm2.put(nums2[i], hm2.get(nums2[i])+<span class="hljs-number">1</span>);
            } <span class="hljs-keyword">else</span> {
                hm2.put(nums2[i], <span class="hljs-number">1</span>);
            }
        }
        
        <span class="hljs-keyword">for</span>(Integer key: hm1.keySet()) {
        <span class="hljs-comment">// After having the frequency of both array, have to check which of them    are intersecting</span>
            <span class="hljs-keyword">if</span>(hm2.containsKey(key)) {
                <span class="hljs-comment">// Get the minimum frequency of intersection one</span>
                <span class="hljs-keyword">int</span> x = Math.min(hm2.get(key), hm1.get(key));
                <span class="hljs-keyword">while</span>(x != <span class="hljs-number">0</span>) {
                    arr.add(key);
                    x--;
                }
            }
        }

        <span class="hljs-keyword">int</span> res[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.size()];
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.size(); i++) res[i] = arr.get(i);
        <span class="hljs-keyword">return</span> res;
    }
}</code></pre><p>Or,</p>
<pre class="hljs"><code><span class="hljs-comment">/* Simply Hash all the Elements of one array into a hashmap with their frequencies and then
   traverse other array and check if this element exists in hashmap if yes then,decrease its
   frequency by 1
*/</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] intersect(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2) {
        ArrayList&lt;Integer&gt; arr = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        Map&lt;Integer,Integer&gt; map1 = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
       
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;nums1.length;i++){
            map1.put(nums1[i],map1.getOrDefault(nums1[i],<span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);
        }
        
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;nums2.length;i++){
            <span class="hljs-keyword">if</span>(map1.containsKey(nums2[i]) &amp;&amp; map1.get(nums2[i]) &gt; <span class="hljs-number">0</span>){
                arr.add(nums2[i]);
                map1.put(nums2[i],map1.get(nums2[i]) - <span class="hljs-number">1</span>);
            }
        }
        
        <span class="hljs-keyword">int</span> size = arr.size();
        <span class="hljs-keyword">int</span> [] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[size];
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;size;i++){
            ans[i] = arr.get(i);
        }
        
        <span class="hljs-keyword">return</span> ans;
    }
}</code></pre><h2 id="best-time-to-buy-and-sell-stock"><a class="header-link" href="#best-time-to-buy-and-sell-stock"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">Best Time to Buy and Sell Stock</a></h2>
<blockquote>
<p>You are given an array prices where prices[i] is the price of a given stock on the ith day.
You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.
Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.</p>
</blockquote>
<pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>{
        <span class="hljs-keyword">int</span> maxProfit = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> minPrice = prices[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.length; i++) {
            minPrice = Math.min(minPrice, prices[i]);
            maxProfit = Math.max(maxProfit, prices[i]-minPrice);
        }
        <span class="hljs-keyword">return</span> maxProfit;
    }
}</code></pre><p>Or,</p>
<pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>{
        <span class="hljs-keyword">int</span> minimumPriceSoFar = Integer.MAX_VALUE;
        <span class="hljs-keyword">int</span> overAllProfit = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> profitIfSoldToday = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; prices.length; i++) {
            <span class="hljs-keyword">if</span>(prices[i] &lt; minimumPriceSoFar) {
                minimumPriceSoFar = prices[i];
            }
            profitIfSoldToday = prices[i]-minimumPriceSoFar;
            <span class="hljs-keyword">if</span>(profitIfSoldToday &gt; overAllProfit) {
                overAllProfit = profitIfSoldToday;
            }
        }
        <span class="hljs-keyword">return</span> overAllProfit;
    }
}</code></pre><hr>

<h2 align="center">Day 4</h2>

<h2 id="reshape-the-matrix"><a class="header-link" href="#reshape-the-matrix"></a><a href="https://leetcode.com/problems/reshape-the-matrix/">Reshape the Matrix</a></h2>
<blockquote>
<p>In MATLAB, there is a handy function called reshape which can reshape an m x n matrix into a new one with a different size r x c keeping its original data.
You are given an m x n matrix mat and two integers r and c representing the number of rows and the number of columns of the wanted reshaped matrix.
The reshaped matrix should be filled with all the elements of the original matrix in the same row-traversing order as they were.
If the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.</p>
</blockquote>
<pre class="hljs"><code><span class="hljs-comment">// Brute Force - Copy original 2D into 1D array, then array 1D into required 2D</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] matrixReshape(<span class="hljs-keyword">int</span>[][] mat, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c) {
      <span class="hljs-comment">// Result 2D Matrix</span>
        <span class="hljs-keyword">int</span>[][] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[r][c];
        <span class="hljs-comment">// Source Matrix Size</span>
        <span class="hljs-keyword">int</span> rowOfMatrix = mat.length;
        <span class="hljs-keyword">int</span> colOfMatrix = mat[<span class="hljs-number">0</span>].length;
        <span class="hljs-comment">// If target matrix is feasible</span>
        <span class="hljs-keyword">boolean</span> matrixReshapePossible = (rowOfMatrix * colOfMatrix) == r * c ? <span class="hljs-keyword">true</span> : <span class="hljs-keyword">false</span>;

        <span class="hljs-keyword">if</span>(matrixReshapePossible){
            <span class="hljs-comment">//2D matrix to 1D array conversion</span>
            <span class="hljs-keyword">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[rowOfMatrix * colOfMatrix];
            <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rowOfMatrix ; i++ ){
                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; colOfMatrix; j++){
                    ans[idx] = mat[i][j];
                    idx++;
                }
            }
            
            <span class="hljs-comment">//Copy elements from 1D array to result matrix;</span>
            idx = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; r; i++){
                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; c; j++){
                    result[i][j] = ans[idx];
                    idx++;
                }
            }
            <span class="hljs-keyword">return</span> result;
        }
        <span class="hljs-keyword">return</span> mat;
    }
}</code></pre><p>Or,</p>
<pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] matrixReshape(<span class="hljs-keyword">int</span>[][] mat, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c) {
        <span class="hljs-comment">// extract source matrix row/column count</span>
        <span class="hljs-keyword">int</span> m = mat.length;
        <span class="hljs-keyword">int</span> n = mat[<span class="hljs-number">0</span>].length;
        <span class="hljs-comment">// check if the target matrix is possible?</span>
        <span class="hljs-keyword">if</span>(r*c != m*n) <span class="hljs-keyword">return</span> mat;
        <span class="hljs-comment">// what if source and destination shape is same</span>
        <span class="hljs-keyword">if</span>(r==m &amp;&amp; c==n) <span class="hljs-keyword">return</span> mat;
        <span class="hljs-keyword">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[r][c];
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;r*c; i++){
            <span class="hljs-comment">// for [3,1] position = 10, Row = Position/Column (3)</span>
            <span class="hljs-comment">// Col = Position%Column (1)</span>
            res[i/c][i%c] = mat[i/n][i%n];
        }
        <span class="hljs-keyword">return</span> res;
    }
}</code></pre><h2 id="pascals-triangle"><a class="header-link" href="#pascals-triangle"></a><a href="https://leetcode.com/problems/pascals-triangle/">Pascal&#39;s Triangle</a></h2>
<blockquote>
<p>Given an integer numRows, return the first numRows of Pascal&#39;s triangle.</p>
</blockquote>
<pre class="hljs"><code><span class="hljs-comment">// ðŸ’¡ Pascalâ€™s Triangle number at [i,j] position</span>
<span class="hljs-comment">// If Row = 5, Column = 3, Value at [5,3] = R-1C C-1; i.e. 4c2 = (4*3)/(2*1) = 6;</span>
<span class="hljs-comment">// ðŸ’¡ Print Nth Row:</span>
<span class="hljs-comment">// Brute force: loop up to n and calculate value for each position using above formula, but its O(n^2)</span>
<span class="hljs-comment">// Better Approach: ?</span>

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class="hljs-keyword">int</span> numRows) {
        <span class="hljs-comment">// Final Result List</span>
        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();
        <span class="hljs-comment">// To keep track of previous Row</span>
        ArrayList&lt;Integer&gt; pre = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= numRows; i++) {
            <span class="hljs-comment">// Intermediate Temp List</span>
            ArrayList&lt;Integer&gt; save = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++)
                <span class="hljs-keyword">if</span> (j == <span class="hljs-number">1</span> || j == i) save.add(<span class="hljs-number">1</span>);
                <span class="hljs-keyword">else</span> save.add(pre.get(j-<span class="hljs-number">1</span>) + pre.get(j-<span class="hljs-number">2</span>)); <span class="hljs-comment">// ?</span>
            result.add(save);
            pre = save;
        }
        <span class="hljs-keyword">return</span> result;
    }
}</code></pre><hr>

<h2 align="center">Day 5</h2>

<h2 id="valid-sudoku"><a class="header-link" href="#valid-sudoku"></a><a href="https://leetcode.com/problems/valid-sudoku/">Valid Sudoku</a></h2>
<blockquote>
<p>Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:
Each row must contain the digits 1-9 without repetition.
Each column must contain the digits 1-9 without repetition.
Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.</p>
</blockquote>
<pre class="hljs"><code><span class="hljs-comment">// The idea is, if some element at a certain column is added to a set, then it wont allow duplicates. Hence, return false.</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidSudoku</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>{
        Set seen = <span class="hljs-keyword">new</span> HashSet();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">9</span>; ++i) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">9</span>; ++j) {
                <span class="hljs-keyword">char</span> number = board[i][j];
                <span class="hljs-keyword">if</span> (number != <span class="hljs-string">&#x27;.&#x27;</span>)
                    <span class="hljs-keyword">if</span> (!seen.add(number + <span class="hljs-string">&quot; in row &quot;</span> + i) ||
                        !seen.add(number + <span class="hljs-string">&quot; in column &quot;</span> + j) ||
                        !seen.add(number + <span class="hljs-string">&quot; in block &quot;</span> + i/<span class="hljs-number">3</span> + <span class="hljs-string">&quot;-&quot;</span> + j/<span class="hljs-number">3</span>))
                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }
}</code></pre><h2 id="search-a-2d-matrix"><a class="header-link" href="#search-a-2d-matrix"></a><a href="https://leetcode.com/problems/search-a-2d-matrix/">Search a 2D Matrix</a></h2>
<blockquote>
<p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:
Integers in each row are sorted from left to right.
The first integer of each row is greater than the last integer of the previous row.</p>
</blockquote>
<pre class="hljs"><code><span class="hljs-comment">// Brute Force</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> target)</span> </span>{
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; matrix.length; i++) {
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; matrix[<span class="hljs-number">0</span>].length; j++) {
                <span class="hljs-keyword">if</span>(matrix[i][j] == target) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
}</code></pre><p>Or,</p>
<pre class="hljs"><code><span class="hljs-comment">// Optimized using binary search approach since the elements are sorted.</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> target)</span> </span>{
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (i &lt; matrix.length &amp;&amp; j &gt;= <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">if</span> (matrix[i][j] == target) {
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[i][j] &gt; target) {
                    j--;
                } <span class="hljs-keyword">else</span> {
                    i++;
                }
            }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    }
}</code></pre><hr>

<h2 align="center">Day 6</h2>

<h2 id="first-unique-character-in-a-string"><a class="header-link" href="#first-unique-character-in-a-string"></a><a href="https://leetcode.com/problems/first-unique-character-in-a-string/">First Unique Character in a String</a></h2>
<blockquote>
<p>Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.</p>
</blockquote>
<pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(String s)</span> </span>{
        <span class="hljs-comment">// To create counter of each character</span>
        Map&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++) {
            <span class="hljs-keyword">char</span> c = s.charAt(i);
            <span class="hljs-keyword">if</span>(map.containsKey(c)) {
                map.put(c, map.get(c)+<span class="hljs-number">1</span>);
            }
            <span class="hljs-keyword">else</span>
                map.put(c,<span class="hljs-number">1</span>);
        }
        <span class="hljs-comment">// To check whose frequency is 1</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++) {
            <span class="hljs-keyword">char</span> c = s.charAt(i);
            <span class="hljs-keyword">if</span>(map.get(c)==<span class="hljs-number">1</span>)
                <span class="hljs-keyword">return</span> i;
        }
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }
}</code></pre><h2 id="ransom-note"><a class="header-link" href="#ransom-note"></a><a href="https://leetcode.com/problems/ransom-note/">Ransom Note</a></h2>
<blockquote>
<p>Given two stings ransomNote and magazine, return true if ransomNote can be constructed from magazine and false otherwise.
Each letter in magazine can only be used once in ransomNote.</p>
</blockquote>
<pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canConstruct</span><span class="hljs-params">(String ransomNote, String magazine)</span> </span>{
        Map&lt;Character, Integer&gt; magazineMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; magazine.length(); i++) {
            <span class="hljs-keyword">char</span> c = magazine.charAt(i);
            <span class="hljs-keyword">if</span>(magazineMap.containsKey(c)) {
                magazineMap.put(c, magazineMap.get(c)+<span class="hljs-number">1</span>);
            }
            <span class="hljs-keyword">else</span>
                magazineMap.put(c,<span class="hljs-number">1</span>);
        }
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ransomNote.length(); i++) {
            <span class="hljs-keyword">char</span> c = ransomNote.charAt(i);
            <span class="hljs-comment">// if character is not present in source hashmap, return false</span>
            <span class="hljs-keyword">if</span>(magazineMap.get(c) == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
            <span class="hljs-comment">// if character&#x27;s value is already reduced to zero, return false</span>
            <span class="hljs-keyword">if</span>(magazineMap.get(c) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
            <span class="hljs-comment">// if character&#x27;s value is greater or equal to 1, decrease the value by 1</span>
            <span class="hljs-keyword">if</span>(magazineMap.get(c) &gt;= <span class="hljs-number">1</span>) magazineMap.put(c, magazineMap.get(c)-<span class="hljs-number">1</span>);
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }
}</code></pre><p>Or,</p>
<pre class="hljs"><code><span class="hljs-comment">// Other enhanced loop &amp; methods</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canConstruct</span><span class="hljs-params">(String ransomNote, String magazine)</span> </span>{
        Map&lt;Character, Integer&gt; counts = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c: magazine.toCharArray()) {
            counts.put(c, counts.getOrDefault(c,<span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);
        }
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c: ransomNote.toCharArray()) {
            <span class="hljs-keyword">if</span>(!counts.containsKey(c) || counts.get(c) &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
            counts.put(c, counts.get(c) - <span class="hljs-number">1</span>);
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }
}</code></pre><h2 id="valid-anagram"><a class="header-link" href="#valid-anagram"></a><a href="https://leetcode.com/problems/valid-anagram/">Valid Anagram</a></h2>
<blockquote>
<p>Given two strings s and t, return true if t is an anagram of s, and false otherwise.</p>
</blockquote>
<pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(String s, String t)</span> </span>{
      <span class="hljs-keyword">int</span>[] alphabet = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];
      <span class="hljs-comment">// a unicode value = 97; so if in string s comes up, it means 97-97 = 0; so, alphabet[0] = 1 and so on,</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) alphabet[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;
      <span class="hljs-comment">// In this loop, we are decreasing the corresponding value</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; t.length(); i++) alphabet[t.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]--;
      <span class="hljs-comment">// We are checking if all the values are zero or not</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : alphabet) <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }
}</code></pre></body>
</html>
